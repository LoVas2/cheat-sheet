# ObjectsA Kubernetes object is a "record of intent"--once you create the object, the Kubernetes system will constantly work to ensure that object exists. By creating an object, you're effectively telling the Kubernetes system what you want your cluster's workload to look like; this is your cluster's desired state.Pour créer les objets il est possible de passer directement par l'API de K8s ou d'utiliser des outils comme kubectl qui effectue les requêtes pour nous.## Spec and StatusLes objets sont définis par 2 choses *spec* et *status*.* **spec** : définis l'état désiré de l'objet (desired state)* **status** : décrit l'état courant de l'objet## DescriptionDescription des objets : [K8s API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/)Les objets sont identifiés par leur nom qui doit être unique. Mais 2 objets différents (Pod / Service par exemple) peuvent avoir le même nom.Pour sélectionner des objets, on peut utiliser les labels et les annotations. Ceux-ci ne sont pas obligatoirement uniques.```yamlapiVersion: apps/v1 # Required: K8s API versionkind: Deployment # Required: object's kindmetadata: # Required: object's id  name: nginx-deployment  # UID:  # namespace:  labels:    app: myapp    environment: dev  annotations:    imageregistry: "https://github.com/"spec: # Required: object's desired state  selector:    matchLabels:      app: nginx  replicas: 2 # tells deployment to run 2 pods matching the template  template:    metadata:      labels:        app: nginx    spec:      containers:      - name: nginx        image: nginx:1.14.2        ports:        - containerPort: 80```## NamespacesK8s supporte plusieurs clusters virtuels fonctionnant sur le même cluster physique. Ces clusters virtuels sont appelés *namespaces*.Chaque noms d'objet est unique par namespace.On commence à utiliser plusieurs namespaces quand on fonctionne avec de grandes équipes de dev.Tous les objets ne sont pas dans des namespaces, comme les namespaces eux-mêmes, les noeuds et les volumes persistens.Pour voir quels objets sont dans les namespaces : ``kubectl api-resources --namespaced=false``### Default namespacesK8s démarre avec 4 namespaces :* **default** : pour les objets où pas de namespace est défini* **kube-system** : pour les objets créés par le système de K8s* **kube-public** : accessible en lecture pour tout le monde. Pour les objets qui doivent être accessible par tout le cluster.* **kube-node-lease** : permet d'améliorer la performance sur les noeuds pour vérifier leurs états. Chaque noeud a un objet dans ce namespace.### Utilisation :* Pour utiliser un namespace en ligne de commande kubectl, il faut utiliser : ``--namespace``* Pour définir un namespace par défaut : ``kubectl config set-context --current --namespace=<my-namespace>``## Labels & Selectors### LabelsLes labels sont sous la forme *key/value*. Ils servent à sélectionner les objets et à les identifier. <br/>On peut ajouter les labels lors de la création ou alors quand les objets sont déjà créés.Exemple de labels :* "release" : "stable", "release" : "dev"* "environment" : "dev", "environment" : "qa", "environment" : "production"Pour requêter les labels, on peut utiliser : * les opérateurs d'égalité : ``env=prod,app!=my-app`` -> sélectionne les objets avec le label "env" égale à "prod" et qui ont soit pas de clé "app" soit la clé app non égale à "my-app"* les sélecteurs : ``in | notin | exists`` -> exemple : ``environment in (production, qa)`` | ``tier notin (frontend, backend)`` | ``partition`` | ``!partition``### SelectorsKubectl exemples :```kubectl get pods -l environment=production,tier=frontendkubectl get pods -l 'environment in (production),tier in (frontend)'``` Les services identifie les pods sur lesquels ils agissent en utilisant les labels :```yamlselector:    component: redis```Certains objets (Job, Deployment, ReplicaSet, and DaemonSet) supporte les sélecteurs de groupe :```yamlselector:  matchLabels:    component: redis  matchExpressions:    - {key: tier, operator: In, values: [cache]}    - {key: environment, operator: NotIn, values: [dev]}```Les valeurs possibles pour *operator* : In, NotIn, Exits et DoesNotExist.### Fields selectorsOn peut également effectuer des requêtes sur les champs via le *field-selector*. Exemple :``kubectl get pods --field-selector=status.phase!=Running,spec.restartPolicy=Always``## AnnotationsLes annotations sont comme les labels, elles permettent d'attacher des informations sur les objets. Mais elle ne permette pas de sélectionner les objets.Par contre, elles peuvent inclure des caractères non permis dans les labels.Exemple d'utilisation : * Information comme n° de release, git branch, dateTime* Pointers pour le logging, monitoring# WorkloadUn workload est une application sur Kubernetes. Un Pod représente un ensemble de conteneur.## Workload resources :Kubernetes fournis plusieurs types de ressources pour gérer les pods :* **Deployment et ReplicaSet :** pour gérer les applications sans état (stateless)* **StatefulSet :** permet de gérer les applications avec état et un *PersistentVolume*. Les Pods partagent le même volume pour leurs données.* **DaemonSet :** pour gérer des applications aidant les noeuds (comme le réseau par exemple). L'avantage des DaemonSet est qu'il créé 1 Pod par noeud et dès qu'on créé un noeud, un Pod y sera automatiquement ajouté. Exemple ``The reason behind that is kube-proxy is needed on every node in cluster to run IP tables so that every node can access every pod no matter on which node it resides. Hence, when we make kube-proxy a daemonset and another node is added to cluster at later time kube-proxy is automatically spawned on that node.``* **Job et CronJob :** pour lancer des tâches. Job = 1 seule tâche, CronJob = tâche récurrente.## Garbage collectorLe rôle du garbage collector est de supprimé les objets qui avaient un Owner et qui n'en ont plus.Par exemple un RS a un ensemble de Pods. Les enfants sont appelés *Dependents* de l'objet parent.Chaque dependent a une propriété `metadata.ownerReferences` qui pointe vers l'objet parent.Il existe 2 types de suppression pour le GC :* Foreground : L'objet parent est annoté "deletion in progress" et les enfants sont ensuites supprimés* Background : L'objet parent est supprimé et le GC supprimera les enfants par la suite.## ServicesQuand on créé un service, K8s créé une entrée DNS de la forme *<service-name>.<namespace-name>.svc.cluster.local*.Si on ne précise pas le namespace, il prend le service dans le local. Si on veut 